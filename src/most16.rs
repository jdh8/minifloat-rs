// This file is part of the minifloat project.
//
// Copyright (C) 2025 Chen-Pang He <jdh8@skymizer.com>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

use crate::NanStyle;
use core::cmp::Ordering;
use core::ops::Neg;

/// IEEE-like minifloat taking at most 16 bits
///
/// * `E`: exponent bit-width
/// * `M`: explicit significand (mantissa) bit-width
///
/// Constraints:
/// * `E` + `M` < 16 (there is always a sign bit)
/// * `E` ≥ 2 (or use an integer type instead)
/// * `M` > 0 if [`Self::N`] is [`IEEE`][NanStyle::IEEE] (∞ ≠ NaN)
///
/// Types generated by [`minifloat!`][crate::minifloat] implement this
/// trait.
pub trait Most16<const M: u32>:
    Sized + Copy + PartialEq + PartialOrd + Neg<Output = Self>
{
    /// Exponent bit-width
    const E: u32;

    /// Significand (mantissa) precision
    const M: u32 = M;

    /// Exponent bias
    const B: i32 = (1 << (Self::E - 1)) - 1;

    /// NaN encoding style
    const N: NanStyle;

    /// Total bitwidth
    const BITWIDTH: u32 = 1 + Self::E + Self::M;

    /// The radix of the internal representation
    const RADIX: u32 = 2;

    /// The number of digits in the significand, including the implicit leading bit
    ///
    /// Equal to `M` + 1
    const MANTISSA_DIGITS: u32 = Self::M + 1;

    /// The maximum exponent
    ///
    /// Normal numbers < 1 &times; 2<sup>`MAX_EXP`</sup>.
    const MAX_EXP: i32 = (1 << Self::E)
        - Self::B
        - match Self::N {
            NanStyle::IEEE => 1,
            NanStyle::FN => (Self::M == 0) as i32,
            NanStyle::FNUZ => 0,
        };

    /// One greater than the minimum normal exponent
    ///
    /// Normal numbers ≥ 0.5 &times; 2<sup>`MIN_EXP`</sup>.
    ///
    /// This quirk comes from C macros `FLT_MIN_EXP` and friends.  However, it
    /// is no big deal to mistake it since [[`MIN_POSITIVE`][Self::MIN_POSITIVE],
    /// 2 &times; `MIN_POSITIVE`] is a buffer zone where numbers can be
    /// interpreted as normal or subnormal.
    const MIN_EXP: i32 = 2 - Self::B;

    /// Approximate number of significant decimal digits
    ///
    /// Equal to floor([`M`][Self::M] log<sub>10</sub>(2))
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    const DIGITS: u32 = (Self::M as f64 * crate::LOG10_2) as u32;

    /// Maximum <var>x</var> such that 10<sup>`x`</sup> is normal
    ///
    /// Equal to floor(log<sub>10</sub>([`MAX`][Self::MAX]))
    #[allow(clippy::cast_possible_truncation)]
    const MAX_10_EXP: i32 = {
        let exponent = (1 << Self::E) - Self::B - matches!(Self::N, NanStyle::IEEE) as i32;
        let precision = Self::M + !matches!(Self::N, NanStyle::FN) as u32;
        let log2_max = exponent as f64 + crate::LOG2_SIGNIFICAND[precision as usize];
        (log2_max * crate::LOG10_2) as i32
    };

    /// Minimum <var>x</var> such that 10<sup>`x`</sup> is normal
    ///
    /// Equal to ceil(log<sub>10</sub>([`MIN_POSITIVE`][Self::MIN_POSITIVE]))
    #[allow(clippy::cast_possible_truncation)]
    const MIN_10_EXP: i32 = ((Self::MIN_EXP - 1) as f64 * crate::LOG10_2) as i32;

    /// One representation of NaN
    const NAN: Self;

    /// The largest number of this type
    ///
    /// This value would be +∞ if the type has infinities.  Otherwise, it is
    /// the maximum finite representation.  This value is also the result of
    /// a positive overflow.
    const HUGE: Self;

    /// The maximum finite number
    const MAX: Self;

    /// The smallest positive (subnormal) number
    const TINY: Self;

    /// The smallest positive normal number
    ///
    /// Equal to 2<sup>[`MIN_EXP`][Self::MIN_EXP]&minus;1</sup>
    const MIN_POSITIVE: Self;

    /// [Machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon)
    ///
    /// The difference between 1.0 and the next larger representable number.
    ///
    /// Equal to 2<sup>&minus;`M`</sup>.
    const EPSILON: Self;

    /// The minimum finite number
    ///
    /// Equal to &minus;[`MAX`][Self::MAX]
    const MIN: Self;

    /// Magnitude mask for internal usage
    const ABS_MASK: u16 = (1 << (Self::E + Self::M)) - 1;

    /// Raw transmutation from `u16`
    #[must_use]
    fn from_bits(v: u16) -> Self;

    /// Raw transmutation to `u16`
    #[must_use]
    fn to_bits(self) -> u16;

    /// IEEE 754 total-ordering predicate
    ///
    /// The normative definition is lengthy, but it is essentially comparing
    /// sign-magnitude notations.
    ///
    /// See also [`f32::total_cmp`],
    /// <https://en.wikipedia.org/wiki/IEEE_754#Total-ordering_predicate>
    #[must_use]
    fn total_cmp(&self, other: &Self) -> Ordering;

    /// Check if the value is NaN
    #[must_use]
    fn is_nan(self) -> bool {
        match Self::N {
            NanStyle::IEEE => self.to_bits() & Self::ABS_MASK > Self::HUGE.to_bits(),
            NanStyle::FN => self.to_bits() & Self::ABS_MASK == Self::NAN.to_bits() & Self::ABS_MASK,
            NanStyle::FNUZ => self.to_bits() == Self::NAN.to_bits(),
        }
    }

    /// Check if the value is positive or negative infinity
    #[must_use]
    fn is_infinite(self) -> bool {
        matches!(Self::N, NanStyle::IEEE) && self.to_bits() & Self::ABS_MASK == Self::HUGE.to_bits()
    }

    /// Check if the value is finite, i.e. neither infinite nor NaN
    #[must_use]
    fn is_finite(self) -> bool {
        match Self::N {
            NanStyle::IEEE => self.to_bits() & Self::ABS_MASK < Self::HUGE.to_bits(),
            _ => !self.is_nan(),
        }
    }

    /// Check if the value is [subnormal]
    ///
    /// [subnormal]: https://en.wikipedia.org/wiki/Subnormal_number
    #[must_use]
    fn is_subnormal(self) -> bool {
        matches!(self.classify(), core::num::FpCategory::Subnormal)
    }

    /// Check if the value is normal, i.e. not zero, [subnormal], infinite, or NaN
    ///
    /// [subnormal]: https://en.wikipedia.org/wiki/Subnormal_number
    #[must_use]
    fn is_normal(self) -> bool {
        matches!(self.classify(), core::num::FpCategory::Normal)
    }

    /// Classify the value into a floating-point category
    ///
    /// If only one property is going to be tested, it is generally faster to
    /// use the specific predicate instead.
    #[must_use]
    fn classify(self) -> core::num::FpCategory {
        if self.is_nan() {
            core::num::FpCategory::Nan
        } else if self.is_infinite() {
            core::num::FpCategory::Infinite
        } else {
            let exp_mask = ((1 << Self::E) - 1) << Self::M;
            let man_mask = (1 << Self::M) - 1;

            match (self.to_bits() & exp_mask, self.to_bits() & man_mask) {
                (0, 0) => core::num::FpCategory::Zero,
                (0, _) => core::num::FpCategory::Subnormal,
                (_, _) => core::num::FpCategory::Normal,
            }
        }
    }

    /// Compute the absolute value
    #[must_use]
    fn abs(self) -> Self {
        if Self::N == NanStyle::FNUZ && self.to_bits() == Self::NAN.to_bits() {
            return Self::NAN;
        }
        Self::from_bits(self.to_bits() & Self::ABS_MASK)
    }

    /// Check if the sign bit is clear
    #[must_use]
    fn is_sign_positive(self) -> bool {
        self.to_bits() >> (Self::E + Self::M) & 1 == 0
    }

    /// Check if the sign bit is set
    #[must_use]
    fn is_sign_negative(self) -> bool {
        self.to_bits() >> (Self::E + Self::M) & 1 == 1
    }
}

/// Lossy conversion to [`f64`]
fn as_f64<const M: u32, T: Most16<M>>(x: T) -> f64 {
    let bias = (1 << (T::E - 1)) - 1;
    let sign = if x.is_sign_negative() { -1.0 } else { 1.0 };
    let magnitude = x.abs().to_bits();

    if x.is_nan() {
        return f64::NAN.copysign(sign);
    }
    if x.is_infinite() {
        return f64::INFINITY * sign;
    }
    if i32::from(magnitude) >= (f64::MAX_EXP + bias) << M {
        return f64::INFINITY * sign;
    }
    if magnitude < 1 << M {
        #[allow(clippy::cast_possible_wrap)]
        let shift = T::MIN_EXP - T::MANTISSA_DIGITS as i32;
        return crate::exp2i(shift) * sign * f64::from(magnitude);
    }
    if i32::from(magnitude >> M) < f64::MIN_EXP + bias {
        let significand = (magnitude & ((1 << M) - 1)) | 1 << M;
        let exponent = i32::from(magnitude >> M) - bias;
        #[allow(clippy::cast_possible_wrap)]
        return crate::exp2i(exponent - M as i32) * sign * f64::from(significand);
    }
    let shift = f64::MANTISSA_DIGITS - T::MANTISSA_DIGITS;
    #[allow(clippy::cast_sign_loss)]
    let diff = (T::MIN_EXP - f64::MIN_EXP) as u64;
    let diff = diff << (f64::MANTISSA_DIGITS - 1);
    let sign = u64::from(x.is_sign_negative()) << 63;
    f64::from_bits(((u64::from(magnitude) << shift) + diff) | sign)
}
