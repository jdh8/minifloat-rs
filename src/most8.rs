// This file is part of the minifloat project.
//
// Copyright (C) 2025 Chen-Pang He <jdh8@skymizer.com>
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

use crate::NanStyle;
use core::cmp::Ordering;
use core::ops::Neg;

/// IEEE-like minifloat taking at most 8 bits
///
/// * `E`: exponent bit-width
/// * `M`: explicit significand (mantissa) bit-width
///
/// Constraints:
/// * `E` + `M` < 8 (there is always a sign bit)
/// * `E` ≥ 2 (or use an integer type instead)
/// * `M` > 0 if [`Self::N`] is [`IEEE`][NanStyle::IEEE] (∞ ≠ NaN)
///
/// Types generated by [`minifloat!`][crate::minifloat] implement this
/// trait.
pub trait Most8<const E: u32, const M: u32>:
    Sized + Copy + PartialEq + PartialOrd + Neg<Output = Self>
{
    /// Exponent bit-width
    const E: u32 = E;

    /// Significand (mantissa) precision
    const M: u32 = M;

    /// Exponent bias
    const B: i32;

    /// NaN encoding style
    const N: NanStyle;

    /// Total bitwidth
    const BITWIDTH: u32 = 1 + E + M;

    /// The radix of the internal representation
    const RADIX: u32 = 2;

    /// The number of digits in the significand, including the implicit leading bit
    ///
    /// Equal to `M` + 1
    const MANTISSA_DIGITS: u32 = M + 1;

    /// The maximum exponent
    ///
    /// Normal numbers < 1 &times; 2<sup>`MAX_EXP`</sup>.
    const MAX_EXP: i32 = (1 << E)
        - Self::B
        - match Self::N {
            NanStyle::IEEE => 1,
            NanStyle::FN => (M == 0) as i32,
            NanStyle::FNUZ => 0,
        };

    /// One greater than the minimum normal exponent
    ///
    /// Normal numbers ≥ 0.5 &times; 2<sup>`MIN_EXP`</sup>.
    ///
    /// This quirk comes from C macros `FLT_MIN_EXP` and friends.  However, it
    /// is no big deal to mistake it since [[`MIN_POSITIVE`][Self::MIN_POSITIVE],
    /// 2 &times; `MIN_POSITIVE`] is a buffer zone where numbers can be
    /// interpreted as normal or subnormal.
    const MIN_EXP: i32 = 2 - Self::B;

    /// Approximate number of significant decimal digits
    ///
    /// Equal to floor([`M`][Self::M] log<sub>10</sub>(2))
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    const DIGITS: u32 = (M as f64 * crate::LOG10_2) as u32;

    /// Maximum <var>x</var> such that 10<sup>`x`</sup> is normal
    ///
    /// Equal to floor(log<sub>10</sub>([`MAX`][Self::MAX]))
    #[allow(clippy::cast_possible_truncation)]
    const MAX_10_EXP: i32 = {
        let exponent = (1 << E) - Self::B - matches!(Self::N, NanStyle::IEEE) as i32;
        let precision = M + !matches!(Self::N, NanStyle::FN) as u32;
        let log2_max = exponent as f64 + crate::LOG2_SIGNIFICAND[precision as usize];
        (log2_max * crate::LOG10_2) as i32
    };

    /// Minimum <var>x</var> such that 10<sup>`x`</sup> is normal
    ///
    /// Equal to ceil(log<sub>10</sub>([`MIN_POSITIVE`][Self::MIN_POSITIVE]))
    #[allow(clippy::cast_possible_truncation)]
    const MIN_10_EXP: i32 = ((Self::MIN_EXP - 1) as f64 * crate::LOG10_2) as i32;

    /// One representation of NaN
    const NAN: Self;

    /// The largest number of this type
    ///
    /// This value would be +∞ if the type has infinities.  Otherwise, it is
    /// the maximum finite representation.  This value is also the result of
    /// a positive overflow.
    const HUGE: Self;

    /// The maximum finite number
    const MAX: Self;

    /// The smallest positive (subnormal) number
    const TINY: Self;

    /// The smallest positive normal number
    ///
    /// Equal to 2<sup>[`MIN_EXP`][Self::MIN_EXP]&minus;1</sup>
    const MIN_POSITIVE: Self;

    /// [Machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon)
    ///
    /// The difference between 1.0 and the next larger representable number.
    ///
    /// Equal to 2<sup>&minus;`M`</sup>.
    const EPSILON: Self;

    /// The minimum finite number
    ///
    /// Equal to &minus;[`MAX`][Self::MAX]
    const MIN: Self;

    /// Magnitude mask for internal usage
    const ABS_MASK: u8 = (1 << (E + M)) - 1;

    /// Raw transmutation from `u8`
    #[must_use]
    fn from_bits(v: u8) -> Self;

    /// Raw transmutation to `u8`
    #[must_use]
    fn to_bits(self) -> u8;

    /// IEEE 754 total-ordering predicate
    ///
    /// The normative definition is lengthy, but it is essentially comparing
    /// sign-magnitude notations.
    ///
    /// See also [`f32::total_cmp`],
    /// <https://en.wikipedia.org/wiki/IEEE_754#Total-ordering_predicate>
    #[must_use]
    fn total_cmp(&self, other: &Self) -> Ordering;

    /// Check if the value is NaN
    #[must_use]
    fn is_nan(self) -> bool {
        match Self::N {
            NanStyle::IEEE => self.to_bits() & Self::ABS_MASK > Self::HUGE.to_bits(),
            NanStyle::FN => self.to_bits() & Self::ABS_MASK == Self::NAN.to_bits() & Self::ABS_MASK,
            NanStyle::FNUZ => self.to_bits() == Self::NAN.to_bits(),
        }
    }

    /// Check if the value is positive or negative infinity
    #[must_use]
    fn is_infinite(self) -> bool {
        matches!(Self::N, NanStyle::IEEE) && self.to_bits() & Self::ABS_MASK == Self::HUGE.to_bits()
    }

    /// Check if the value is finite, i.e. neither infinite nor NaN
    #[must_use]
    fn is_finite(self) -> bool {
        match Self::N {
            NanStyle::IEEE => self.to_bits() & Self::ABS_MASK < Self::HUGE.to_bits(),
            _ => !self.is_nan(),
        }
    }

    /// Check if the value is [subnormal]
    ///
    /// [subnormal]: https://en.wikipedia.org/wiki/Subnormal_number
    #[must_use]
    fn is_subnormal(self) -> bool {
        matches!(self.classify(), core::num::FpCategory::Subnormal)
    }

    /// Check if the value is normal, i.e. not zero, [subnormal], infinite, or NaN
    ///
    /// [subnormal]: https://en.wikipedia.org/wiki/Subnormal_number
    #[must_use]
    fn is_normal(self) -> bool {
        matches!(self.classify(), core::num::FpCategory::Normal)
    }

    /// Classify the value into a floating-point category
    ///
    /// If only one property is going to be tested, it is generally faster to
    /// use the specific predicate instead.
    #[must_use]
    fn classify(self) -> core::num::FpCategory {
        if self.is_nan() {
            core::num::FpCategory::Nan
        } else if self.is_infinite() {
            core::num::FpCategory::Infinite
        } else {
            let exp_mask = ((1 << E) - 1) << M;
            let man_mask = (1 << M) - 1;

            match (self.to_bits() & exp_mask, self.to_bits() & man_mask) {
                (0, 0) => core::num::FpCategory::Zero,
                (0, _) => core::num::FpCategory::Subnormal,
                (_, _) => core::num::FpCategory::Normal,
            }
        }
    }

    /// Check if the sign bit is clear
    #[must_use]
    fn is_sign_positive(self) -> bool {
        self.to_bits() >> (E + M) & 1 == 0
    }

    /// Check if the sign bit is set
    #[must_use]
    fn is_sign_negative(self) -> bool {
        self.to_bits() >> (E + M) & 1 == 1
    }

    /// Probably lossy conversion from [`f32`]
    ///
    /// NaNs are preserved.  Overflows result in ±[`HUGE`][Self::HUGE].
    /// Other values are rounded to the nearest representable value.
    #[must_use]
    #[allow(clippy::cast_possible_wrap)]
    fn from_f32(x: f32) -> Self {
        if x.is_nan() {
            let sign_bit = u8::from(x.is_sign_negative()) << (E + M);
            return Self::from_bits(Self::NAN.to_bits() | sign_bit);
        }

        let bits = crate::round_f32_to_precision::<M>(x).to_bits();
        let sign_bit = ((bits >> 31) as u8) << (E + M);
        let diff = (Self::MIN_EXP - f32::MIN_EXP) << M;
        let magnitude = bits << 1 >> (f32::MANTISSA_DIGITS - M);
        let magnitude = magnitude as i32 - diff;

        if magnitude < 1 << M {
            let ticks =
                f64::from(x.abs()) * crate::exp2i(Self::MANTISSA_DIGITS as i32 - Self::MIN_EXP);
            #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
            let ticks = ticks.round_ties_even() as u8;
            return Self::from_bits(
                (u8::from(Self::N != NanStyle::FNUZ || ticks != 0) * sign_bit) | ticks,
            );
        }

        #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
        Self::from_bits(magnitude.min(i32::from(Self::HUGE.to_bits())) as u8 | sign_bit)
    }

    /// Probably lossy conversion from [`f64`]
    ///
    /// NaNs are preserved.  Overflows result in ±[`HUGE`][Self::HUGE].
    /// Other values are rounded to the nearest representable value.
    #[must_use]
    #[allow(clippy::cast_possible_wrap)]
    fn from_f64(x: f64) -> Self {
        if x.is_nan() {
            let sign_bit = u8::from(x.is_sign_negative()) << (E + M);
            return Self::from_bits(Self::NAN.to_bits() | sign_bit);
        }

        let bits = crate::round_f64_to_precision::<M>(x).to_bits();
        let sign_bit = ((bits >> 63) as u8) << (E + M);
        let diff = i64::from(Self::MIN_EXP - f64::MIN_EXP) << M;
        let magnitude = bits << 1 >> (f64::MANTISSA_DIGITS - M);
        let magnitude = magnitude as i64 - diff;

        if magnitude < 1 << M {
            let ticks = x.abs() * crate::exp2i(Self::MANTISSA_DIGITS as i32 - Self::MIN_EXP);
            #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
            let ticks = ticks.round_ties_even() as u8;
            return Self::from_bits(
                (u8::from(Self::N != NanStyle::FNUZ || ticks != 0) * sign_bit) | ticks,
            );
        }

        #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
        Self::from_bits(magnitude.min(i64::from(Self::HUGE.to_bits())) as u8 | sign_bit)
    }

    /// Lossless conversion to [`f32`]
    fn to_f32(self) -> f32 {
        let sign = if self.is_sign_negative() { -1.0 } else { 1.0 };
        let magnitude = self.to_bits() & Self::ABS_MASK;

        if self.is_nan() {
            return f32::NAN.copysign(sign);
        }
        if self.is_infinite() {
            return f32::INFINITY * sign;
        }
        if magnitude < 1 << M {
            #[allow(clippy::cast_possible_wrap)]
            let shift = Self::MIN_EXP - Self::MANTISSA_DIGITS as i32;
            #[allow(clippy::cast_possible_truncation)]
            return (crate::exp2i(shift) * f64::from(sign) * f64::from(magnitude)) as f32;
        }
        let shift = f32::MANTISSA_DIGITS - Self::MANTISSA_DIGITS;
        #[allow(clippy::cast_sign_loss)]
        let diff = (Self::MIN_EXP - f32::MIN_EXP) as u32;
        let diff = diff << (f32::MANTISSA_DIGITS - 1);
        let sign = u32::from(self.is_sign_negative()) << 31;
        f32::from_bits(((u32::from(magnitude) << shift) + diff) | sign)
    }

    /// Lossless conversion to [`f64`]
    fn to_f64(self) -> f64 {
        let sign = if self.is_sign_negative() { -1.0 } else { 1.0 };
        let magnitude = self.to_bits() & Self::ABS_MASK;

        if self.is_nan() {
            return f64::NAN.copysign(sign);
        }
        if self.is_infinite() {
            return f64::INFINITY * sign;
        }
        if magnitude < 1 << M {
            #[allow(clippy::cast_possible_wrap)]
            let shift = Self::MIN_EXP - Self::MANTISSA_DIGITS as i32;
            return crate::exp2i(shift) * sign * f64::from(magnitude);
        }
        let shift = f64::MANTISSA_DIGITS - Self::MANTISSA_DIGITS;
        #[allow(clippy::cast_sign_loss)]
        let diff = (Self::MIN_EXP - f64::MIN_EXP) as u64;
        let diff = diff << (f64::MANTISSA_DIGITS - 1);
        let sign = u64::from(self.is_sign_negative()) << 63;
        f64::from_bits(((u64::from(magnitude) << shift) + diff) | sign)
    }
}